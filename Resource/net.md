# 计网总结

## 1.http 的缓存策略

### 缓存过程

1. 浏览器第一次加载资源，服务器返回 200，浏览器将资源文件从服务器上请求下载下来，并把 response header 及该请求的返回时间一并返回
2. 下一次加载资源，先比较当前时间和上一次返回 200 的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，命中强缓存，不发请求直接从本地缓存中读取该文件（如果浏览器不支持 HTTP1.1，则用 expires 判断是否过期）；如果时间过期，则向服务器发送带有 if-None-Match 和 if-Modified-Since 的请求
3. 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
4. 如果服务器收到的请求没有 Etag 值，则将 if-Modified-Since 和被请求文件的最后修改时间做对比，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

### 缓存的优点

1. 减少了冗余的数据传输，节省了网费
2. 减少了服务器的负担，大大提升了网站的性能
3. 加快了客户端加载网页的速度

浏览器缓存主要有两类：协商缓存和彻底缓存，也称为协商缓存和强缓存

1. 强制缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 network 选项中可以看到该请求返回 200 的状态码
2. 协商缓存：在使用本地缓存之前，需要向服务器发送请求，服务器回根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源；协商缓存可以解决强制缓存的清况下，资源不更新的问题

两者的共同点是：都是从客户端中读取资源；区别是强缓存不会发送请求，协商缓存会发起请求

### 强制缓存中 header 的参数

- Expires：response header 里的过期时间，浏览器再次加载资源时，如果在这个过期时间，则命中强缓存。
- cache-Control：当值设为 max-age=300 时，则代表在这个请求正确的返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，机会命中强缓存。
  - cache-control：除了该字段外，还有下面几个比较常用的设置值。
  - no-cache：不使用本地缓存。需要使用协商缓存，先于服务器确认返回的响应值是否被更改。
  - no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
  - public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
  - private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。

## 2.TCP\UDP

### TCP

面向字节流

### UDP

面向报文段

UDP，用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层。

也就是说无论应用层交给 UDP 多长的报文，它统统发送，一次发送一个报文。

而对接收方，接到后直接去除首部，交给上面的应用层就完成任务。

UDP 报头包括 4 个字段，每个字段，每个字段占用 2 个字节（即 16 个二进制位），标题短，开销小。

## 3.http

- 超文本传输协议，是一种网络通信的规范

- 在这个协议中传输的是完整的、有意义的数据，如 HTML、图片、查询结果等超文本

### http1.0

- 浏览器只可以与服务器保持短暂的连接，每次与服务器请求都会建立一个 TCP 连接

- 如果需要保持长链接需要手动的设置 connection：keep-alive

### http1.1

- 默认打开长链接
- 允许客户端不用等待上次请求结果返回，就可以发送下一次请求，但是服务器端必须按照接受到的客户端请求的先后顺序依次会送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载的过程所需要的时间
- 增加了缓存用的请求头响应头
- 增加了请求的方法

### http2.0

- 多路复用：客户端和浏览器都可以同时发送多个请求或回应，而且不会按照顺序一一对应，这样就避免了“队头阻塞”
- 二进制分帧：http2.0 采用二进制的形式传输数据，每个数据流都以消息的方式进行传递，而消息又由一个或者多个帧组成，多个帧之间可以乱序发送，根据帧首部的流表示可以重新组装，这也是多路复用同时发送数据的实现形式
- 首部压缩
- 服务器推送

### 状态码常见的

- 1xx
  - 100 预请求 比如：http 请求先把请求行发送过去，然后服务器返后浏览器 100 然后浏览器再把剩下的请求头请求体传过去
  - 101 切换协议 比如：https websocket
- 2xx
  - 200 请求成功返回数据
  - 201 Created 已经创建新的资源
  - 202 Accepted 接受请求 但没有执行完成（异步操作）
  - 204 NO Content 处理请求，但没有返回任何内容
- 3xx
  - 301 永久转移
  - 302 临时重定向
  - 304 协商缓存用的
- 4xx
  - 400 Bad Request
  - 401 Unauthrized
  - 403 forbidden
  - 404 not found
- 5xx
  - 503 服务器维护的时候
  - 504 网管超速

### 常用的请求方式

1. **GET**：用于请求指定的资源。GET 方法的请求参数会附在 URL 后面，通过查询字符串传递给服务器。GET 方法是幂等的，即对同一资源的多次请求不会产生副作用，不会修改服务器状态。

2. **POST**：向指定的资源提交数据，并请求服务器接受处理。POST 方法常用于提交表单数据或上传文件等，请求参数在请求体中发送给服务器。POST 方法不是幂等的，多次提交相同数据可能会产生不同的结果。

3. **HEAD**：类似于 GET 方法，但服务器只返回响应头信息，不返回响应体内容。HEAD 方法常用于获取资源的元信息，如响应状态码、响应头部等，而不需要获取实际的资源内容。

4. **PUT**：向指定的资源位置上传新的数据。PUT 方法用于更新资源，客户端需要提供完整的资源内容。如果资源不存在，则会创建一个新资源；如果资源已存在，则会完全替换原有资源。

5. **DELETE**：请求服务器删除指定的资源。DELETE 方法用于删除服务器上的资源，删除后服务器返回 200 OK 或 204 No Content 表示删除成功。DELETE 方法是幂等的，即对同一资源的多次请求会产生相同的结果。

6. **OPTIONS**：用于获取目标资源所支持的通信选项。OPTIONS 方法用于查询服务器支持的 HTTP 方法和各种选项，常用于跨域请求前的预检操作（CORS 预检请求）。

7. **TRACE**：用于测试服务器对当前连接的支持性。TRACE 方法会在最终请求的响应中返回服务器收到的请求内容，用于测试和诊断服务器与客户端之间的通信。

8. **CONNECT**：用于与代理服务器建立隧道连接。CONNECT 方法主要用于 HTTP 代理服务器，客户端通过 CONNECT 方法请求代理服务器与目标服务器建立隧道连接，然后通过该连接发送加密的数据。

这些 HTTP 请求方法通过不同的操作，实现了对于服务器上资源的增删改查等不同的操作。

### 常用的请求头

- Accept：浏览器能够处理的内容类型
- Accept-charset：浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Langugae：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookie：当前页面设置的任何 Cookie
- Host：发出请求的页面所在的域
- Refer：发出请求的页面的 URL
- User-Agent：浏览器的用户代理字符串

### 常用的响应头

- Date：表示消息发送的时间，时间的描述格式由 rfc822 定义
- Server：服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制 Http 缓存
- Content-type：表示后面的文档属于什么类型
  - 常见的属性的值
    1. application/x-www-form-urlencoded：浏览器的原声 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。
    2. multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件使用该种方式
    3. application/json：服务器消息主体是序列化后的 JSON 字符串
    4. text/xml：该种方式主要用来提交 XML 格式的数据。

### http1.0 和 http1.1 之间有哪些区别

- **连接方面**，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免非持久连接时每次需要建立连接的时延。
- **资源请求方面**，在 http1.0 中。存在一些浪费宽带的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求

## 4.https

也就是 http 运行在 SSL/TLS 协议上

如何做

- 对称加密
- 非对称加密
- 混合加密
- 摘要算发：对消息进行 hash sha-2（完整性）
- 数字签名：私钥加密 公钥解密

### 加密握手的过程

1. **客户端发送加密通信请求：**
   客户端向服务器发送一个连接请求，请求中包含支持的加密算法和协议版本。
2. **服务器响应：**
   服务器收到客户端的请求后，会向客户端发送一个响应，其中包含服务器支持的加密算法、协议版本以及服务器的证书。
3. **客户端验证服务器证书：**
   客户端收到服务器的响应后，会验证服务器的证书是否有效，包括证书的有效性、颁发机构的可信度等。如果验证通过，则继续握手，否则会发出警告并终止连接。
4. **生成会话密钥：**
   客户端生成一个随机的会话密钥，并使用服务器的公钥对其进行加密，然后将加密后的会话密钥发送给服务器。
5. **服务器解密会话密钥**：
   服务器收到客户端发送的加密会话密钥后，使用自己的私钥进行解密，得到原始的会话密钥。
6. **建立安全连接**：
   客户端和服务器双方现在都拥有了相同的会话密钥，它们可以使用这个密钥来加密和解密通信内容，从而建立安全的连接。

### 对称密钥和非对称加密的区别和用处

对称密钥加密和非对称密钥加密是两种常见的加密算法，它们在加密和解密过程中有所不同，并且适用于不同的场景。

1. **对称密钥加密**：

   - **原理**：对称密钥加密使用相同的密钥进行加密和解密。发送方和接收方必须事先共享相同的密钥。
   - **特点**：加密和解密速度快，适用于对大量数据进行加密和解密。常见的对称密钥加密算法包括 DES、AES 等。
   - **用处**：通常用于保护大量数据的机密性，如文件加密、数据传输等场景。

2. **非对称密钥加密**：
   - **原理**：非对称密钥加密使用一对密钥，分别是公钥和私钥。公钥用于加密数据，私钥用于解密数据。
   - **特点**：加密和解密速度较慢，但安全性较高。公钥可以公开给任何人使用，私钥只有持有者知道。
   - **用处**：通常用于安全通信和数字签名等场景。例如，SSL/TLS 协议中使用非对称密钥加密来保护网络通信的安全性，数字签名可以确保数据的完整性和来源可信性。

总的来说，对称密钥加密适用于加密大量数据的场景，而非对称密钥加密适用于安全通信和数字签名等场景，它们各有优缺点，可以根据具体需求来选择合适的加密算法。

## 5.DNS

- 首先搜索 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有搜索到，就会搜索操作系统的 DNS 缓存
- 若仍然没有找到，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询到自己的 DNS 缓存，查找成功之后则返回结果
- 若本地域名服务器的 DNS 缓存没有，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级服务器的地址
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发送请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发送请求，最终得到该域名对应的 IP 地址
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来
- 支持浏览器也得到了 IP 地址，并将 IP 地址缓存起来

## 6.CDN

CDN（全称 Content Delivery Network），即内容分发网络。

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。

简单来讲，CDN 就是根据用户位置分配最近的资源。

于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器。

### 6.1 原理分析

在没有应用 CDN 时，我们使用域名访问某个站点时的路径为

> 用户提交域名->浏览器对域名进行解释->DNS 解析的到目的主机的 IP 地址->根据 IP 地址访问发出请求->得到请求数据并回复

应用 CDN 后，DNS 返回的不再是 IP 地址，而是一个 CNAME（Canonical Name）别名记录，指向 CDN 的全局负载均衡

CNAME 实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是 CDN 实现的关键

### 6.2 负载均衡系统

由于没有返回 IP 地址，于是本地 DNS 会向负载均衡系统再次发送请求，则进入到 CDN 的全局负载均衡系统进行智能调度：

- 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点
- 看用户所在运营商网络，找相同的边缘节点
- 检查边缘节点的负载情况，找负载较轻的节点
- 其他，比如节点的“健康情况”、服务能力、带宽、响应时间等

综合上面的因素，得到最适合的边缘节点，然后把这个节点返回给用户，用户就能够就近访问 CDN 的缓存代理

#### 缓存代理

缓存系统是 CDN 的另一个关键的组成部分，缓存系统会有选择地缓存那些最常用的那些资源

其中两个衡量 CDN 服务质量的指标：

- 命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比
- 回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比

缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一次缓存配置高一些，直连源站，二级缓存配置低一些，直连用户。

回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源。

现在的商业 CDN 命中率都在 90%以上，相当于把源站的服务能力放大了 10 倍以上。

### 6.3 总结

CDN 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度。

CDN 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速。

通过 CDN 的负载均衡系统，智能调度边缘节点提供服务，相当于 CDN 服务的大脑，而缓存系统相当于 CDN 的心脏，缓存命中直接返回给用户，否则回源。

## 7.cors

浏览器会先发送一个预检请求（options 请求），以确定请求是否可以跨域

在后端需要配置响应头：

- Access-Control-Allow-origin
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers
- Access-Control-Allow-Credentials

## 8.jsonp

JSONP（JSON with Padding）是一种绕过浏览器的同源策略进行跨域请求的方法，其原理如下：

1. **动态创建 `<script>` 标签：** 客户端通过在页面上动态创建一个 `<script>` 标签，将需要请求的 URL 地址作为其 `src` 属性值。

2. **指定回调函数：** 在请求 URL 中指定一个回调函数的名称，服务器端在响应中将数据作为参数传入该回调函数中。

3. **服务器端返回数据：** 服务器端根据请求参数，生成相应的数据，并将数据作为参数传入回调函数中，以 JavaScript 代码的形式返回给客户端。

4. **执行回调函数：** 客户端收到响应后，浏览器会将返回的 JavaScript 代码当做脚本执行，从而触发回调函数，并将服务器返回的数据作为参数传入回调函数中。

由于 JSONP 是通过 `<script>` 标签加载外部脚本的方式来实现跨域请求的，而 `<script>` 标签的跨域限制不同于 AJAX 请求，不受同源策略的影响，因此 JSONP 能够实现跨域请求。

总的来说，JSONP 的原理就是利用 `<script>` 标签的跨域特性，通过回调函数的方式实现跨域数据的获取和处理。

## 9.七层网络模型

网络的七层模型是指 OSI （Open Systems Interconnecion，开放系统互联）参考模型。它是国际标准化组织（ISO）制定的一个网络通信的标准框架，
用于将网络通信分解为不同的层次，每一层负责特定的功能，从而实现网络通信的可靠性、可扩展性和互操作性。这层模型从底层到顶层依次为：

### 9.1 划分

#### 应用层

应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用间的交互来完成特定的网络应用

该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为了不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。

在应用层交互的数据单元我们称之为报文。

#### 表示层

表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。

该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异。

#### 会话层

会话层就是负责建立、管理和终止表示层之间的通信会话。

该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。

#### 传输层

传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。

传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层。

其中，主要的传输层协议是 TCP 和 UDP。

#### 网络层

两台计算机之间传递数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。

网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。

在发送数据时，网络层把传输层产生的报文或用户数据报分装成组和包，向下传输到数据链路层。

在网络层使用的协议时无连接的网际协议和许多路由协议，因此我们通常把该层简单地称为 IP 层

#### 数据链路层

#### 物理层

## 10.cookie、session、token、jwt

### cookie 的属性

- name：是指 Cookie 的名称，用于标识特定的 Cookie。
- value：是指与 Cookie 关联的具体数据。它是存储在 Cookie 中的值，代表了特定名称的 Cookie 所包含的信息。
- Domin：属性指定 Cookie 的有效路径。只有在匹配该域名或子域名的请求中，浏览器才会发送相应的 Cookie。
- Path：属性指定 Cookie 的有效路径。
- maxAge：属性指定 Cookie 的最大存活时间（单位为秒），即在客户端上保持有效的时间长度。
- Expires：另一种设置 Cookie 过期时间的方式是使用 Expires 属性，它是一个具体的日期和时间。
- httpOnly：属性是一个布尔值，用于限制客户端 JavaScript 对 Cookie 的访问。如果设置为 true，则 Cookie 只会在通过 http。
- Secure：属性是一个布尔值，用于指示是否只在通过 HTTPS 协议建立的安全连接中发送 Cookie。如果设置 true，则 Cookie 只会在通过 HTTPS 发送请求中
- SameSite：属性用于控制跨站点请求中是否发送 Cookie。它可以设置为 Strict、Lax 或 None。Strict 表示只在同一站点的请求中发送 Cookie，Lax 表示在导航到目标站点的安全请求中发送 Cookie，而 None 表示始终在所有请求中发送 Cookie。
- Partition Key：是一个概念，没有直接对应的 Cookie 属性。它通常用于将 Cookie 存储空间分割成不同分区以便不同的应用程序或组件可以独立管理访问自己的 cookie。通过不同的分区键，可以隔离不同的 Cookie 存储，防止冲突和干扰。
- Priority 属性不是 Cookie 的属性，而是一个 HTTP 头字段（非 cookie 属性），用于指示请求中的 Cookie 的优先级。优先级可以是 High、Medium、Low，用于表示 Cookie 的重要程度或处理顺序。这个头字段通常由浏览器使用，以帮助服务器根据需要进行 Cookie 的处理和响应。

## 11.websocket

### 11.1 如何握手

1. **客户端发送连接请求：**客户端通过发送一个 HTTP 请求来请求与服务器建立 WebSocket 连接。这个请求称为 WebSocket 握手请求

   ```http
   GET /chat HTTP/1.1
   Host:example.com
   Upgrate:websocket
   Connection:Upgrate
   Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==
   Sec-WebSocket-Version:13
   ```

   - `Upgrade`: 标明客户端希望升级连接为 WebSocket。
   - `Connection`: 指定为 Upgrade，表示要升级协议。
   - `Sec-WebSocket-Key`: 是一个随机的 Base64 编码字符串，用于验证服务器是否支持 WebSocket 协议。
   - `Sec-WebSocket-Version`: 指定 WebSocket 协议的版本号。

2. **服务器响应请求：**服务器收到 WebSocket 握手请求之后，进行一些验证，并返回一个 HTTP 响应作为确认，这个响应也包含了一些特殊的头部信息。

   ```http
    HTTP/1.1 101 Switch Protocols
    Connection:Upgrade
    Upgrade:websokcet
    Sec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
   ```

   - `Upgrade`: 表明服务器同意升级连接为 WebSocket。
   - `Connection`: 指定为 Upgrade，表示已经升级协议。
   - `Sec-WebSocket-Accept`: 是经过服务器处理后的 Sec-WebSocket-Key，用于确认客户端的请求。

3. **建立连接：**客户端收到服务器的响应后，会确认握手成功，然后就可以开始通过该连接进行双向通信了。连接建立后，通信将不再使用 HTTP 协议，而是使用 WebSocket 协议进行通信。

### 11.2 没有 websocket 的时候以前是怎么实现的？

在 WebSocket 出现之前，Web 应用通常使用以下方法实现实时通信：

1. **轮询（Polling）：**

   - 定期向服务器发送请求，以查看是否有新数据可用。
   - 缺点是频繁的请求会增加服务器负载，并且实时性不高，因为客户端必须等待下一个轮询周期才能获取更新。

   ```html
   <!DOCTYPE html>

   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <meta name="viewport" content="width=" device-width", initial-scale=1.0">
       <title>Document</title>
     </head>

     <body>
       <div id="clock"></div>
       <script>
         setInterval(() => {
           const xhr = new XMLHttpRequest();
           xhr.open("GET", "http://localhost:3000/clock", true);
           xhr.onload = function () {
             clock.innerHTML = xhr.responseText;
           };
           xhr.send();
         }, 1000); // 每隔1s发送一次请求

         // 竞速问题：无法保证请求的先后顺序，可能会出现多个请求返回的时候，同时修改资源。
         // 频繁的网络请求 请求数目多 导致服务端增加负载 客户端请求也会出现性能问题
         // http在发送的时候 会增加http报文（鉴权，内容类型）额外的数据消耗
         // 优点容易实现   缺点不适合实时性比较高的 低并发
       </script>
     </body>
   </html>
   ```

2. **长轮询（Long Polling）：**

   - 客户端向服务器发送请求，服务器保持连接打开，直到有新数据可用或者超时。
   - 当有新数据可用时，服务器响应并关闭连接，客户端立即发起新的请求。
   - 长轮询减少了不必要的请求，但仍然需要频繁的连接和断开操作。

   ```html
   <!DOCTYPE html>
   <html lang="en"></html>
   <head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=" device-width", initial-scale=1.0">
   <title>Document</title>
   </head>
   <body>
   <div id="clock"></div>
   <script>
     // 客户端发送请求之后，服务端响应后，我就发下一次请求
     function longPolling() {
       const xhr = new XMLHttpRequest();
       xhr.open('GET', 'http://localhost:3000/clock', true);
       xhr.onload = function () {
       clock.innerHTML = xhr.responseText;
       longPolling();
       }
       xhr.send();
     }
     longPolling();

     // 长轮询想解决短轮询的问题（希望实时性更强）

     // 1.如果实时性强了，也会造成频繁的网络请求
     // 2.链接堆积问题 这些链接都需要在服务端中保持打开 占用服务端资源

     // 实时性高了，但是要求服务器的并发能力必须强

   </script>
   </body>

   </html>
   ```

## 12.怎么使用 udp 实现 tcp

在面试中，向面试官叙述通过 UDP 实现类似 TCP 的可靠传输过程时，可以按照以下步骤进行清晰、有条理的解释：

### 12.1 概述

首先，简要说明 UDP 和 TCP 的区别以及为什么我们需要通过 UDP 实现类似 TCP 的可靠传输机制。

**示例**：
“UDP 是一种无连接、不可靠的协议，它不保证消息的顺序和到达。而 TCP 是一种面向连接、可靠的协议，提供顺序保证、错误检测和重传机制。在某些情况下，我们可能希望在保持 UDP 低延迟优势的同时，实现类似 TCP 的可靠性。以下是通过 UDP 实现 TCP 特性的过程。”

### 12.2 连接建立

描述如何通过消息交换模拟 TCP 的连接建立过程（类似三次握手）。

**示例**：
“首先，我们需要模拟 TCP 的三次握手过程来建立连接。客户端发送一个连接请求包，服务器接收到后回复一个确认包，客户端再发送一个确认包，双方确认连接已建立。”

### 12.3 数据包序列化

解释如何为每个 UDP 数据包添加序列号，以确保接收方能够按序接收和重组数据包。

**示例**：
“为了保证数据包的顺序，我们为每个 UDP 数据包添加一个序列号。接收方根据序列号来重组数据包，如果发现缺失的数据包，可以请求重传。”

### 12.4 确认机制

说明如何在接收方收到数据包后发送确认消息（ACK），并在未收到确认消息时重传数据包。

**示例**：
“接收方在收到数据包后，会发送一个确认消息（ACK）给发送方。发送方在未收到确认消息时，会在超时后重传数据包，确保数据可靠传输。”

### 12.5 流量控制和拥塞控制

介绍如何实现类似 TCP 的滑动窗口机制，控制发送数据的速率和数量，以适应网络状况。

**示例**：
“为了控制发送数据的速率和数量，我们可以实现类似 TCP 的滑动窗口机制。这可以帮助我们根据网络状况调整数据发送频率，避免网络拥塞。”

### 12.6 超时和重传

讨论设置数据包的发送超时时间，以及在超时未收到确认消息时的重传机制。

**示例**：
“每个数据包都有一个发送超时时间，如果在规定时间内未收到确认消息，发送方会重传数据包。这确保了即使在数据包丢失的情况下，数据也能成功到达接收方。”

### 12.7 连接终止

描述如何模拟 TCP 的四次挥手过程，确保双方能够安全地关闭连接。

**示例**：
“在连接结束时，我们需要模拟 TCP 的四次挥手过程来安全关闭连接。双方通过消息交换确认所有数据包已接收并确认，随后终止连接。”

### 12.8 总结

最后，总结整个实现过程，并强调通过这种方式实现的可靠性和顺序保证。

**示例**：
“通过这些步骤，我们可以在应用层实现基于 UDP 的可靠传输，模拟 TCP 的连接管理、数据包顺序和可靠性保证。这样我们既能保持 UDP 的低延迟特性，又能提供类似 TCP 的可靠传输机制。”

## 13.网络攻击

### 13.1 CSRF 跨站请求伪造

#### CSRF 攻击概述

CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种利用受害者在受攻击网站的登录凭证，以受害者身份发送未经授权的请求的攻击方式。攻击者诱导受害者访问第三方网站，在其中发送请求，利用受害者已登录的凭证执行操作，而受害者毫无察觉。

**CSRF 的典型攻击流程**：

1. 受害者登录了 a.com，并保持了登录状态（Cookie）。
2. 攻击者引诱受害者访问了 b.com。
3. b.com 向 a.com 发送一个请求（例如 `a.com/act=xx`），浏览器会自动携带 a.com 的 Cookie。
4. a.com 接收到请求，由于请求带有合法的 Cookie，误以为是受害者的请求，执行了 `act=xx` 操作。
5. 攻击完成，攻击者冒充受害者执行了操作，而受害者不知情。

**攻击方法**：

- 利用 `<img>`、`<script>` 等标签进行 GET 请求。
- 利用自动提交表单进行 POST 请求。
- 利用 `<a>` 标签伪装成重要链接进行 GET 请求。

#### CSRF 的特点

- 攻击发起在第三方网站，被攻击网站无法防止攻击发生。
- 攻击利用受害者的登录凭证，冒充受害者提交操作，而不是窃取数据。
- 攻击者无法直接获取受害者的登录凭证，只能冒用。

#### CSRF 的预防措施

1. **阻止不明外域的访问**：

   - 通过检测 `Origin` 和 `Referer` 头来阻止跨域请求。

2. **同源检测**：

   - 检查请求的来源是否与当前网站的地址一致。

3. **SameSite Cookie**：

   - 设置 Cookie 的 SameSite 属性为 Strict 或 Lax，限制第三方站点对 Cookie 的访问。

4. **提交时要求附加本域才能获取的信息**：

   - 在提交时要求用户附加一个本域才能获取的信息，如 CSRF Token。

5. **CSRF Token**：

   - 服务器生成一个随机 Token，将其嵌入页面中，然后验证提交请求中的 Token 是否有效。

6. **双重 Cookie 验证**：
   - 服务器端要求每个请求除了携带 CSRF Token 外，还需验证 Cookie 中的其他信息。

#### CSRF Token 的实现流程

**生成 Token**：

- 用户登录时，服务器生成一个随机的 CSRF Token，并将其与用户会话相关联。

**附加 Token**：

- 对于 GET 请求，Token 附加在请求地址中。
- 对于 POST 请求，Token 作为隐藏字段附加在表单中。

**验证 Token**：

- 服务器接收到请求后，验证请求中携带的 Token 是否与用户会话中的 Token 相匹配。

**示例代码**（Node.js + Express）：

```javascript
const express = require("express");
const csrf = require("csurf");
const bodyParser = require("body-parser");
const cookieParser = require("cookie-parser");

const app = express();

app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());

const csrfProtection = csrf({ cookie: true });

app.use(csrfProtection);

app.get("/form", (req, res) => {
  const csrfToken = req.csrfToken();
  res.send(`
        <form action="/process" method="POST">
            <input type="hidden" name="csrftoken" value="${csrfToken}">
            <button type="submit">提交</button>
        </form>
    `);
});

app.post("/process", (req, res) => {
  const token = req.body.csrftoken;
  if (req.csrfToken() !== token) {
    return res.status(403).send("CSRF Token 错误");
  }
  // 处理表单提交
  res.send("提交成功");
});

app.listen(3000, () => {
  console.log("Server is running on port 3000");
});
```

#### 总结

CSRF 是一种常见的 Web 攻击方式，通过各种手段绕过用户的认证和权限，以受害者的身份执行操作。为了防止 CSRF 攻击，开发者应采取有效的预防措施，如 CSRF Token、同源检测、SameSite Cookie 等。CSRF Token 是一种简单有效的防护措施，可以有效地防止大多数 CSRF 攻击。

### 13.2 XSS 跨站脚本攻击

#### XSS 攻击概述

XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的 Web 安全漏洞，允许攻击者将恶意代码注入到提供给其他用户使用的页面中。攻击目标通常是获取存储在客户端（通常是浏览器）中的 cookie 或其他敏感信息，或者冒充用户与网站进行交互。

#### XSS 的攻击场景与类型

1. **存储型 XSS**

   - 攻击步骤：
     - 攻击者将恶意代码提交到目标网站的数据库中。
     - 用户访问目标网站时，服务器将恶意代码从数据库中取出，拼接在 HTML 中返回给用户。
     - 用户浏览器解析执行恶意代码，导致攻击成功。
   - 典型场景：论坛发帖、商品评论、用户私信等带有用户输入内容保存功能的页面。

2. **反射型 XSS**

   - 攻击步骤：
     - 攻击者构造特殊的 URL，其中包含恶意代码。
     - 用户点击带有恶意代码的 URL。
     - 网站服务端从 URL 中取出恶意代码，拼接在 HTML 中返回给浏览器。
     - 用户浏览器解析执行恶意代码，导致攻击成功。
   - 典型场景：通过邮件或社交媒体平台传播包含恶意代码的 URL。

3. **DOM 型 XSS**
   - 攻击步骤：
     - 攻击者构造特殊的 URL，其中包含恶意代码。
     - 用户打开带有恶意代码的 URL。
     - 用户浏览器执行恶意代码，前端 JavaScript 取出 URL 中的恶意代码并执行。
     - 攻击成功后，恶意代码可以窃取用户数据或冒充用户行为。
   - 典型场景：通过前端 JavaScript 操作执行恶意代码，而非服务器端返回恶意内容。

#### XSS 的防范措施

1. **过滤输入**

   - 对用户输入进行严格的输入验证和过滤，排除或转义特殊字符。

2. **输出编码**

   - 将所有用户提供的数据在输出到 HTML 页面之前进行适当的编码。
   - **HTML Entity 编码**：将特殊字符转换为 HTML 实体，如 `<` 转换为 `&lt;`。
   - **JavaScript 编码**：将数据转换为 JavaScript 字符串，防止恶意代码执行。

3. **使用安全的 API**

   - 尽量使用安全的 API，避免使用危险的方法，如 `.innerHTML`、`.outerHTML`、`document.write()` 等。

4. **HTTP Header 安全策略**

   - 设置适当的 HTTP 头部，如 `Content-Security-Policy`（CSP），限制页面可以加载的资源和执行的脚本。

5. **XSS Filter**

   - 使用现代的浏览器自带的 XSS 过滤器。

6. **Cookie 安全设置**
   - 使用 HttpOnly 和 Secure 标志来设置 Cookie，防止被 XSS 攻击窃取。

#### XSS 的防范示例

以下是一个简单的 Node.js + Express 示例，演示了如何防止存储型和反射型 XSS 攻击：

```javascript
const express = require("express");
const bodyParser = require("body-parser");
const cookieParser = require("cookie-parser");
const { escape } = require("html-escaper");

const app = express();

app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());

// 存储型 XSS 防范
let comments = [];

app.post("/comment", (req, res) => {
  const { comment } = req.body;
  // 过滤用户输入的恶意代码
  const safeComment = escape(comment);
  comments.push(safeComment);
  res.send("评论成功！");
});

app.get("/comments", (req, res) => {
  // 输出时确保转义
  res.send(`
        <ul>
            ${comments.map((comment) => `<li>${escape(comment)}</li>`).join("")}
        </ul>
    `);
});

// 反射型 XSS 防范
app.get("/search", (req, res) => {
  const { keyword } = req.query;
  // 过滤 URL 参数中的恶意代码
  const safeKeyword = escape(keyword);
  res.send(`
        <input type="text" value="${safeKeyword}">
        <button>搜索</button>
        <div>您搜索的关键词是：${safeKeyword}</div>
    `);
});

app.listen(3000, () => {
  console.log("Server is running on port 3000");
});
```

#### 结论

XSS 攻击是 Web 应用安全面临的重要威胁之一，开发者需要通过过滤和编码用户输入、使用安全的 API 和 HTTP 头设置等措施来有效防范 XSS 攻击。合理的安全策略和前端输出编码是防止 XSS 攻击的关键。

### 13.3 中间人攻击（Man-in-the-Middle Attack）

#### 中间人攻击概述

中间人攻击（Man-in-the-Middle Attack，简称 MITM 攻击）是一种广泛存在的网络安全攻击方式，它允许攻击者截取和篡改通过网络传输的信息。在这种攻击中，攻击者能够截取、发送和接收双方之间的通信，而双方则认为他们正在与对方直接通信。

#### 中间人攻击的原理

1. **截取通信**

   - 攻击者在受害者与目标之间插入自己，使得受害者和目标认为他们是直接通信的。
   - 攻击者能够监控通信内容，甚至可以修改或篡改通信内容。

2. **两次独立通信**
   - 攻击者同时与受害者和目标建立两次独立的通信，这使得他能够看到双方的通信内容，并且能够对通信内容进行修改。

#### 中间人攻击的常见形式

1. **Wi-Fi 热点攻击**

   - 攻击者创建一个恶意的 Wi-Fi 热点，并将其命名与周围的真实热点相似，以吸引受害者连接。
   - 通过恶意的热点，攻击者能够截取所有通过该网络传输的信息，如登录凭证、敏感数据等。

2. **HTTPS 的欺骗**

   - 攻击者可能通过某些手段，使受害者的浏览器认为它正在与目标网站建立加密的 HTTPS 连接。
   - 攻击者实际上在受害者和目标之间，解密和篡改所有的加密流量。

3. **DNS 欺骗**

   - 攻击者可以通过修改 DNS 解析结果，将受害者的域名解析到恶意 IP 地址上。
   - 这样攻击者能够截取和修改所有进出受害者计算机的通信。

4. **SSL Stripping**
   - 攻击者可能会将 HTTPS 请求转换为普通的 HTTP 请求，从而绕过加密保护，截取和修改用户的信息。

#### 中间人攻击的防范措施

1. **使用加密通信**

   - 使用 HTTPS 和 SSL/TLS 进行通信，可以有效防止中间人攻击，因为攻击者无法解密和篡改加密通信。

2. **安全的公共 Wi-Fi**

   - 避免使用未知或不安全的公共 Wi-Fi 热点，尤其是在敏感操作（如银行交易、账号登录）时。

3. **HSTS（HTTP Strict Transport Security）**

   - HSTS 可以强制客户端（如浏览器）只使用 HTTPS 与服务器通信，从而防止 SSL Stripping 攻击。

4. **双向认证**

   - 对于服务器和客户端都要进行认证，确保双方的身份是可信的。

5. **域名校验**

   - 确保 DNS 解析的准确性，尽可能使用 DNSSEC（DNS Security Extensions）来防止 DNS 欺骗。

6. **安全通信协议**
   - 使用安全通信协议，如 IPsec，可以在网络层面防范中间人攻击。

#### 中间人攻击的实际案例

1. **Wi-Fi 热点攻击**

   - 在公共场所的 Wi-Fi 热点中，攻击者可以设置伪造的热点，以收集用户的数据或篡改用户的流量。

2. **SSL Stripping**

   - 攻击者将 HTTPS 请求转换为 HTTP 请求，使得用户通信不再受到加密保护，从而截取敏感信息。

3. **DNS 欺骗**
   - 攻击者通过修改 DNS 解析结果，将受害者的域名解析到恶意 IP 地址上，从而截取和修改所有进出受害者计算机的通信。

#### 结论

中间人攻击是一种严重的网络安全威胁，攻击者可以在受害者和目标之间插入自己，截取、修改甚至篡改通信内容。为了防范中间人攻击，用户和服务提供者应采取加密通信、双向认证、安全的公共 Wi-Fi 使用等措施，确保通信的安全性和完整性。

## 网络模型

### 1.OSI 七层模型

| OSI 参考模型 |          各层的解释          |
| :----------: | :--------------------------: |
|    应用层    |      为应用程序提供服务      |
|    表示层    |    数据格式转化、数据加密    |
|    会话层    |     建立、管理和维护会话     |
|    传输层    | 建立、管理和维护端到端的连接 |
|    网络层    |      IP 选址及路由选择       |
|  数据链路层  |            物理层            |
