# React

## 组件基础

- 事件
- 高阶组件、Render props、hooks 的区别
- React Fiber 的理解
- React.Component 和 React.PureComponent 的区别
- Component、Element、Instance 之间有什么区别
- React.createClass 和 extends Component 的区别
- React 高阶组件
- componentWillReceiveProps 的理解
- 那些方法可以触发 React 重新渲染
- React 如何判断什么时候重新渲染组件
- React 声明组件有哪几种方法，有什么不同
- 对有状态组件和无状态组件的理解及使用场景
-

### 1.React 事件机制

#### 事件代理

- React 并不是将 click 事件绑定到了 div 的真实 DOM 上，而是在 document 处监听了所有的事件，当事件发生并且冒泡到 document 处的时候，React 将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。
- 除此之外，冒泡到 document 上的事件也不是原生的浏览器事件，而是由 react 自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用 event.preventDefault()方法，而不是调用 event.stopProppagation()方法。

#### 合成事件

- JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。
- 另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。

#### 实现合成事件的目的

- 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；
- 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。

### 2.React 的事件与原生 HTML 事件之间的区别

1. **事件命名方式**：

   - **原生 HTML 事件**：事件名称通常是**全小写**，例如 `onclick`。
   - **React 事件**：使用**小驼峰命名**，例如 `onClick`。

2. **事件处理函数的语法**：

   - **原生 HTML 事件**：通常使用**字符串**来指定事件处理器，如 `<button onclick="handleClick()">`。
   - **React 事件**：使用**函数**来指定事件处理器，如 `<button onClick={handleClick}>`，并且传递的是一个真正的 JavaScript 函数对象，而不是字符串。

3. **阻止默认行为**：

   - **原生 HTML 事件**：可以通过 `return false` 来阻止事件的默认行为。
   - **React 事件**：需要显式调用 `event.preventDefault()` 来阻止默认行为，因为 React 事件系统对默认行为的控制方式更为严格，避免了使用 `return false` 导致的一些隐式副作用。

4. **合成事件（SyntheticEvent）**：
   React 的事件系统使用了**合成事件**（SyntheticEvent）来模拟原生事件的行为。合成事件是对原生 DOM 事件的封装，提供跨浏览器的兼容性，并且还提供了额外的功能。它们有以下优点：

   - **跨平台、跨浏览器兼容性**：React 抹平了浏览器之间的差异，开发者不需要关心不同浏览器中事件的差异。
   - **性能优化**：React 将事件存储在一个事件池中，并且复用事件对象，避免频繁创建和销毁事件对象，减少垃圾回收的压力。

5. **事件的执行顺序**：

   - **原生事件**通常先执行，然后是**合成事件**。React 的事件代理机制将所有事件监听统一放在 `document` 上，所以当事件冒泡到 `document` 时，React 才会触发合成事件。
   - 因此，避免将**原生 DOM 事件**和**React 合成事件**混用，因为如果在原生事件中阻止了事件冒泡，React 的合成事件将无法触发。

6. **React 的事件系统的优势**：

   - **统一管理**：React 能够更好地管理事件，包括在组件卸载时自动移除事件监听。
   - **事务机制**：React 的合成事件可以与 React 内部的事务机制进行集成，确保在某些情况下（如批量更新或异步渲染）能够正确执行事件处理。

#### 结论

React 的合成事件系统通过对事件对象的封装和事件代理，简化了开发者的事件管理工作，同时提供了更好的跨浏览器兼容性和性能优化。

### 3.React 组件中怎么做事件代理？原理是什么？

React 基于 Virtual DOM 实现了一个 SyntheticEvent 层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合 W3C 标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。
在 React 底层，主要对合成事件做了两件事：

事件委派： React 会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。
自动绑定： React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件

---

### 1.React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代

React 中的 **高阶组件（HOC）**、**Render props** 和 **Hooks** 都是为了解决代码复用而出现的不同技术，它们各自有优缺点，并随着 React 的发展不断迭代。

#### 1. 高阶组件（HOC）

高阶组件是一种复用组件逻辑的模式，它的主要思路是：**接收一个组件作为参数，返回一个新的组件**。这种模式允许你将组件逻辑抽取出来并在多个组件中使用。

**优点**：

- 可以实现逻辑的复用。
- 易于与现有代码兼容。

**缺点**：

- 增加了组件层级，容易导致“嵌套地狱”。
- 属性命名冲突，使用时需要注意 props 的传递。

#### 2. Render props

Render props 是通过 **将一个函数作为 prop 传递给组件** 来复用逻辑。这个函数通常负责决定组件需要渲染什么。

**优点**：

- 非常灵活，能够根据具体的渲染需求动态地修改渲染结果。
- 可以避免 HOC 的一些问题，比如属性命名冲突。

**缺点**：

- 会导致代码中出现复杂的嵌套结构，影响可读性。

#### 3. Hooks

React 16.8 引入的 Hooks 是目前最流行的复用逻辑方式。它允许你在 **函数组件中使用状态和其他 React 特性**，从而摆脱了类组件的限制。通过 `useState`、`useEffect` 等钩子，开发者可以更灵活地组织逻辑。

**优点**：

- 函数式编程风格，逻辑更清晰。
- 不会增加组件层级，避免嵌套地狱。
- 灵活且强大，适用于大部分场景。

**缺点**：

- 对类组件不适用。
- 某些复杂场景可能需要自定义 Hook 或配合其他方案。

#### 为什么要不断迭代？

React 的演变是为了 **提高开发体验、减少复杂性并解决已有技术的局限性**。HOC 和 Render props 都有效解决了代码复用的问题，但它们各自有缺陷，尤其是随着组件树变得复杂，它们的嵌套层级会影响代码的可读性和维护性。而 Hooks 通过简化逻辑的表达、减少层级嵌套，在绝大多数场景下提供了更优的解决方案，因此成为了现在的主流

---

### 1.对于 React-Fiber 的理解，他解决了什么问题？

你对 React Fiber 的理解可以从以下几个步骤逐步展开：

#### 1. **没有 React Fiber 的时候会有什么问题？**

在 React Fiber 之前，React 采用的是**同步递归更新**的方式。React 会从根节点开始递归更新所有子节点，一旦开始，更新过程就无法中断，直到全部完成。这种方式在处理小规模的组件树时没有问题，但当组件树非常大、UI 复杂时，会出现以下问题：

- **长时间更新阻塞主线程**：由于更新过程是同步的，某个耗时操作可能会让浏览器在更新时长时间失去响应，导致卡顿或掉帧。
- **用户体验不佳**：UI 更新的过程中，用户交互响应（如点击、滚动等）可能会被延迟，影响用户体验。

#### 2. **React 是如何工作的？**

React 的工作原理基于**虚拟 DOM（Virtual DOM）**，它会将状态变化映射到 UI 更新中。React 采用了两步流程：

- **协调（Reconciliation）**：在这个阶段，React 会比较新旧虚拟 DOM，并生成一组 DOM 变更补丁。
- **渲染（Rendering）**：将这些补丁应用到实际的 DOM 上。

在传统的 React 实现中，**协调阶段**是递归同步的，因此如果组件树过大，协调的耗时就会很长。

#### 3. **React Fiber 解决了什么问题？**

你对 React Fiber 的理解非常全面！可以总结为以下几点：

##### 1. **核心目标**

React Fiber 的核心目标是 **将递归同步更新改为增量异步更新**，使得 React 在渲染时能够中断、恢复或终止更新，从而解决大规模组件渲染导致的 UI 卡顿问题。

##### 2. **关键特性**

- **可中断渲染**：将大的更新任务分成多个小任务，让更新可以随时暂停，处理更紧急的任务（如用户输入、动画），从而避免长时间的 UI 阻塞。
- **优先级调度**：通过任务调度机制，React 可以根据任务的重要性设定优先级，优先处理高优先级任务，延迟低优先级任务，增强应用的流畅性。
- **并发模式的支持**：Fiber 架构为后续引入的并发模式（Concurrent Mode）打下基础，允许 React 同时处理多个渲染任务，提高渲染效率。

##### 3. **核心思想：协程**

React Fiber 的渲染机制类似于**协程**，它允许任务主动让出 CPU 执行权，将控制权交还给浏览器，优先处理更高优先级的任务。这种**“让出机制”**使得浏览器可以更灵活地安排渲染和用户交互操作，进而优化用户体验。

通过引入 Fiber，React 能够更高效地应对复杂的 UI 渲染场景，避免一次性操作大量 DOM 节点，并在浏览器的优化（如 JIT 编译和 reflow 修正）中获得更多的性能提升。

这个架构的设计不仅提升了渲染的灵活性，还为 React 的未来发展提供了更多可能性，比如实现真正的并发渲染等。

---

### 1.React.Component 和 React.PureComponent 的区别

`React.Component` 和 `React.PureComponent` 都是用于创建类组件的基类，但它们之间有一些关键区别，主要体现在 **性能优化** 方面。

#### 1. **React.Component**

- `React.Component` 是 React 类组件的基类，它没有内置的性能优化机制。
- **当组件的状态（state）或属性（props）发生变化时**，`React.Component` 默认会重新渲染组件，无论状态或属性值是否真的发生了变化。

#### 2. **React.PureComponent**

- `React.PureComponent` 继承自 `React.Component`，它与 `Component` 的功能基本相同，唯一的区别在于：`PureComponent` **自动实现了浅比较（shallow comparison）** 来优化性能。
- **浅比较**：`PureComponent` 会在 `props` 和 `state` 变化时，进行浅层比较。如果比较结果相同，它就会跳过渲染，避免不必要的重新渲染，从而提升性能。

#### 3. **区别总结**

- **性能优化**：
  - `React.Component`：没有任何优化，每次 `props` 或 `state` 更新都会触发重新渲染。
  - `React.PureComponent`：自动执行浅比较，只有在 `props` 或 `state` 的值确实发生变化时，才会重新渲染。
- **适用场景**：
  - `React.Component` 适用于需要灵活处理深层对象比较的情况，因为 `PureComponent` 只做浅比较，如果传递的 `props` 是复杂对象（如数组或对象），并且它的内部内容改变了，但引用没有变，`PureComponent` 可能不会察觉到变化，导致渲染结果不正确。
  - `React.PureComponent` 更适合用于**纯函数组件**，即组件的 `props` 和 `state` 是简单数据类型，适合性能优化的场景。

#### 4. **浅比较的局限性**

- `React.PureComponent` 的浅比较仅比较对象的引用，而不是对象的深层内容。因此，如果 `props` 或 `state` 中包含复杂的嵌套对象，`PureComponent` 可能不会检测到内部属性的变化，这种情况下需要小心使用，或者手动处理比较逻辑。

#### 总结

- `React.Component`：没有性能优化，适合需要处理复杂逻辑的组件。
- `React.PureComponent`：内置浅比较，适合在性能敏感场景下使用，但需要注意传递复杂对象时的局限性。

---

### 1.Component、Element、Instance 之间有什么区别

#### 1. **元素（Element）**

- **元素是 React 的最小构建块**，它们是描述 UI 的对象。
- React 元素是不可变的，创建后不能修改。每次状态或属性改变时，React 会创建一个新的元素。
- 元素可以通过 `props` 包含其他元素，从而形成一个嵌套的元素树，用于表示最终的 UI 结构。
- **创建成本低**：React 元素只是一个简单的 JavaScript 对象，创建和销毁它们的开销非常小。

#### 2. **组件（Component）**

- 组件是 React 用来构建 UI 的更高级别的抽象。组件可以是函数组件或类组件。
  - **函数组件（Functional Component）**：本质上是一个接收 `props` 作为参数的函数，并返回 React 元素树。
  - **类组件（Class Component）**：通过类定义，并包含一个 `render()` 方法，接收 `props` 和 `state` 作为输入，返回 React 元素树。
- 组件让我们能够将 UI 拆分成独立的、可复用的片段。

#### 3. **实例（Instance）**

- **实例** 是指类组件的实例。每个类组件在渲染时都会有一个实例，它通过 `this` 关键字引用，用来存储组件的本地状态和响应生命周期事件（如 `componentDidMount`、`componentDidUpdate`）。
- **函数式组件没有实例**，因为它们是无状态的，React 不需要为它们维护 `this` 或生命周期函数。函数组件主要依赖 `hooks` 来管理状态和副作用。

### 1.React 高阶组件是什么，和普通的组件有什么区别，适用什么场景

> 官方解释：高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。

高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由 React 自身的组合性质必然产生的。我们将它们成为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。

1. HOC 的优缺点
   - 优点：逻辑复用、不影响被包裹组件的内部逻辑
   - 缺点：HOC 传递给被包裹组件的 props 容易和被包裹后的组件重名，进而被覆盖
2. 适用场景
   - 代码复用，逻辑抽象
   - 渲染劫持
   - state 抽象和更改
   - Props 更改
3. 具体应用例子
   - **权限控制**：利用高阶组件的条件渲染特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和页面元素级别
